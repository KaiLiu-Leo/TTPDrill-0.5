import os
from allennlp.predictors.predictor import Predictor
from StanfordServer import StanfordServer
from nltk.stem import WordNetLemmatizer, PorterStemmer



# Stanford CoreNLP Server Paths
if os.name == 'nt':
    JAVA_HOME = 'C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\java.exe'
    DOWNLOAD_HOME = 'Downloads'
    STANFORD_HOME = 'stanford-corenlp-full-2018-10-05'
else:
    JAVA_HOME = '/usr/lib/jvm/java-8-oracle/'
    DOWNLOAD_HOME = 'ttp_sense_python'
    STANFORD_HOME = 'lib'
STANFORD_SERVER = 'http://127.0.0.1:9000'

model_STANFORD = StanfordServer(JAVA_HOME, DOWNLOAD_HOME, STANFORD_HOME, STANFORD_SERVER).startServer()

AllenNLP_PATH = 'resources/bert-base-srl-2019.06.17.tar.gz'
model_AllenNLP_SRL = Predictor.from_path(AllenNLP_PATH)

AllenNLP_COREF_PATH = 'resources/coref-model-2018.02.05.tar.gz'
model_AllenNLP_Coref = Predictor.from_path(AllenNLP_COREF_PATH)
# model_AllenNLP_Coref = model_AllenNLP_SRL

stemmer = PorterStemmer()
lemmatizer = WordNetLemmatizer()

isLemmatize = True
isStem = True
# if reading from server, isFile=False
isFile = True
isGhaithOntology = False
isDependencyParser = False
BM25_THRESHOLD = 2.0
# top_n represents the top matches with the mitre
top_n = 100
import preProcessTool as pretool
preprocessOntologies = pretool.preProcessTool(model_AllenNLP_SRL,model_STANFORD,isGhaithOntology)

import cyber_object
cyber_object.combine_cyber_object()

import bm25_match
cyber_model, cyber_corpus = bm25_match.create_cyber_model()

# ontology_model
bm25_model, tokenized_corpus, ttp_id, bow_mapped = bm25_match.create_ontology_bm_model(file_name='ontology/examples/ontoloy_example_description.csv')
# bm25_model, tokenized_corpus, ttp_id, bow_mapped = bm25_match.create_ontology_bm_model(file_name='ontology/examples/ontology_from_examples.csv')


extracted_list = [{'text': 'on june 9th, 2017 morphisec lab published a blog post detailing a new infection vector technique using an rtf document containing an embedded javascript ole object.', 'bow': [['use', 'rtf', 'document', 'contain', 'embed', 'javascript', 'ole', 'object'], ['contain', 'embed', 'javascript', 'ole', 'object'], ['embed', 'javascript', 'ole', 'object']], 'compact_vector': [{'what': 'using', 'where': 'rtf document', 'why': '', 'how': '', 'when': ''}, {'what': 'embedded', 'where': 'javascript ole object','why': '', 'how': '', 'when': ''}]}, {'text': 'when clicked  it launches [not cyber object] an infection chain made up of javascript, and a final  shellcode payload that makes  use of  dns to load additional shellcode from a remote command and control server.', 'bow': [['launch', 'infect', 'chain', 'made', 'javascript', ',', 'final', 'shellcod', 'payload', 'make', 'use', 'dn', 'load', 'addit', 'shellcod', 'remot', 'command', 'control', 'server'], ['use', 'dn']], 'compact_vector': [{'what': 'launches', 'where': 'infection chain made javascript , final payload makes shellcode', 'why': '', 'how': '', 'when': 'when clicked'}, {'what': 'use', 'where': 'dns', 'why': 'load additional shellcode remote command control server', 'how': '', 'when': ''}]}, {'text': "in this collaboration post with morphisec lab and cisco's research and efficacy team, we are now publishing details of this new document variant that makes use of an lnk embedded ole object, which extracts a javascript bot from a document object, and injects a stealer dll in memory using powershell.", 'bow': [['embed', 'ole', 'object'], ['extract', 'javascript', 'bot'], ['inject', 'stealer', 'dll'], ['use', 'powershel']], 'compact_vector': [{'what': 'embedded', 'where': 'ole object', 'why': '', 'how': '', 'when': ''}, {'what': 'extracts', 'where': 'javascript bot', 'why': '', 'how': '', 'when': ''}, {'what': 'injects', 'where': 'stealer dll', 'why': '', 'how': 'using powershell', 'when': ''}, {'what': 'using', 'where': 'powershell', 'why': '', 'how': '', 'when': ''}]}, {'text': 'the details we are releasing are to provide insight into attack methodologies being employed by sophisticated groups such as fin7 who are consistently changing techniques between attacks to avoid detection,', 'bow': [], 'compact_vector': []}, {'text': 'this is relevant to the constantly changing threats that are affecting multiple types of industries on a daily basis.', 'bow': [], 'compact_vector': []}, {'text': 'the dropper variant that we encountered makes use of an lnk file to execute wscript.exe with the beginning of the javascript chain from a word document object.', 'bow': [['make', 'use', 'lnk', 'file']], 'compact_vector': [{'what': 'makes', 'where': 'use lnk file', 'why': 'execute wscript.exe beginning javascript chain word document object', 'how': '', 'when': ''}]}, {'text': 'this chain involves a substantial amount of base64 encoded javascript files that make up each component of the javascript bot.', 'bow': [['involv', 'substanti', 'amount', 'base64', 'encod', 'javascript', 'file', 'make','compon', 'javascript', 'bot'], ['encod', 'javascript', 'file'], ['make', 'compon', 'javascript', 'bot']], 'compact_vector': [{'what': 'involves', 'where': 'substantial amount base64', 'why': '', 'how': '', 'when': ''}, {'what': 'encoded', 'where': 'files', 'why': '', 'how': '', 'when': ''}, {'what': 'make', 'where': 'component javascript bot', 'why': '', 'how': '', 'when': ''}]}, {'text': 'it also contains the reflective dll injection powershell code to inject an information stealing malware variant dll which will be discussed further.', 'bow': [['contain', 'reflect', 'dll', 'inject', 'powershel', 'code', 'inject', 'inform', 'steal', 'malwar', 'variant', 'dll', 'discuss'], ['inject', 'inform', 'steal', 'malwar', 'variant', 'dll', 'discuss']], 'compact_vector': [{'what': 'contains', 'where': 'reflective injection powershell code dll', 'why': '', 'how': '', 'when': ''}, {'what': 'inject', 'where': 'information stealing malware variant dll discussed', 'why': '', 'how': '', 'when': ''}]}, {'text': 'a single one of these documents can produce as many as 40 javascript files.', 'bow': [], 'compact_vector': []}, {'text': 'the majority of the javascript obfuscation is nested base64 encodings.', 'bow': [], 'compact_vector': []}, {'text': 'base64 is a binary to text encoding scheme which can be used to represent any type of data.', 'bow': [['use', 'binari', 'text', 'encod', 'scheme']], 'compact_vector': [{'what': 'used', 'where': 'binary text encoding scheme', 'why': 'represent type data', 'how': '', 'when': ''}]}, {'text': 'in the case of these documents it is used to encode javascript functionality multiple times, likely in order to avoid common analysis techniques employed by traditional anti-virus software which only emulate javascript instructions for a limited amount of iterations.', 'bow': [['encod', 'javascript', 'function'], ['avoid', 'common', 'analysi', 'techniqu', 'employ', 'tradit', 'anti', 'viru', 'softwar', 'emul', 'javascript', 'instruct', 'limit', 'amount', 'iter'], ['employ', 'common', 'analysi', 'techniqu'], ['emul', 'javascript', 'instruct']], 'compact_vector': [{'what': 'encode', 'where': 'functionality', 'why': '', 'how': '', 'when': 'multiple times'}, {'what': 'avoid', 'where': 'traditional anti virus software', 'why': '', 'how': '', 'when': ''}, {'what': 'employed', 'where': 'common analysis techniques', 'why': '', 'how': '', 'when': ''}, {'what': 'emulate', 'where': 'javascript instructions', 'why': '', 'how': '', 'when': 'for a limited amount of iterations'}]}, {'text': 'the base64 blobs are hardcoded, or comma separated, which are then concatenated and decoded making up the next javascript code to be executed.', 'bow': [['hardcod', 'base64', 'blob'], ['make', 'next', 'javascript', 'code', 'execut'], ['execut', 'next', 'javascript', 'code']], 'compact_vector':[{'what': 'hardcoded', 'where': 'base64 blobs', 'why': '', 'how': '', 'when': ''}, {'what': 'executed', 'where': 'next javascript code', 'why': '', 'how': '', 'when': ''}]}, {'text': 'it is decoded using an cdo.message activexobject invocation and specifying the contenttransferencoding to be base64 (note that the windows-1251 charset is cyrillic, which may indicate russian origin).', 'bow': [['specifi', 'contenttransferencod', 'base64']], 'compact_vector': [{'what': 'specifying', 'where': 'contenttransferencoding base64', 'why': '', 'how': '', 'when': ''}]}, {'text': 'this is then evaluated using an obfuscated function invocation.', 'bow': [['use', 'obfusc', 'function', 'invoc'], ['obfusc', 'function']], 'compact_vector': [{'what': 'using', 'where': 'invocation', 'why': '', 'how': '', 'when': ''}, {'what': 'obfuscated', 'where': 'function', 'why': '', 'how': '', 'when': ''}]}, {'text': 'these base64 decoding steps leadto various execution branches of javascript bot functionality, and the injection of a stealer dll into memory.', 'bow': [], 'compact_vector': []}, {'text': "one of the final components of these javascript 'decoding chains' is a powershell reflective dll injection script which contains copy pasted functions from powersploit's invoke-reflectivepeinjection.", 'bow': [['contain', 'copi', 'past', 'function', 'powersploit', "'s", 'invok', 'reflectivepeinject']], 'compact_vector': [{'what': 'contains', 'where': "copy pasted functions powersploit 's invoke reflectivepeinjection", 'why': '', 'how': '', 'when': ''}]}, {'text': 'the dll is de-obfuscated by decoding the base64 blob and uses io.compression.deflatestream to decompress the resulting bytes.', 'bow': [['obfusc', 'dll'], ['decod', 'base64', 'blob'], ['decompress', 'result', 'byte']], 'compact_vector': [{'what': 'obfuscated', 'where': 'dll', 'why': '', 'how': 'decoding base64 blob', 'when': ''}, {'what': 'decoding', 'where': 'base64 blob', 'why': '', 'how': '', 'when': ''}, {'what': 'decompress', 'where': 'resulting bytes', 'why': '', 'how': '', 'when': ''}]}, {'text': 'in order to recover the dll we can simply write the decompressed bytes to disk using [io.file]..writeallbytes.', 'bow': [['recov', 'dll'], ['decompress', 'byte']], 'compact_vector': [{'what': 'recover', 'where': 'dll', 'why': '', 'how': '', 'when': ''}, {'what': 'decompressed', 'where': 'bytes', 'why': '', 'how': '', 'when': ''}]}, {'text': 'import hashing functionality involves resolving the export table for a given dll (common for packers/malware).', 'bow': [['involv', 'resolv', 'export', 'tabl', 'given', 'dll', '(', 'common', 'packer', '/', 'malwar', ')'], ['resolv', 'export', 'tabl', 'given', 'dll', '(', 'common', 'packer', '/', 'malwar', ')']], 'compact_vector': [{'what': 'resolving', 'where': 'export table given dll ( common packers / malware)', 'why': '', 'how': '', 'when': ''}]}, {'text': 'then using xor and rol algorithm over given export values to compare against given hashes for exports to resolve.', 'bow': [['use', 'xor', 'rol', 'algorithm', 'given', 'export', 'valu']], 'compact_vector':[{'what': 'using', 'where': 'xor rol algorithm given export values', 'why': 'compare given hashes exports resolve', 'how': '', 'when': 'then'}]}, {'text': 'this dll also contains similar stealer functionality, e.g the decryption of intelliform data using cryptunprotectdata by hashing cached urls.', 'bow': [['contain', 'similar', 'stealer', 'function'], ['use', 'cryptunprotectdata'], ['hash', 'cach', 'url'], ['cach', 'url']], 'compact_vector': [{'what': 'contains', 'where': 'similar stealer functionality', 'why': '', 'how': '', 'when': ''}, {'what': 'using', 'where': 'cryptunprotectdata', 'why': '', 'how': 'hashing cached urls', 'when': ''}, {'what': 'cached', 'where': 'urls', 'why': '', 'how': '', 'when': ''}]}, {'text': 'this binary also contains outlook and firefox stealer functionality and the ability to steal login information from google chrome, chromium, forks of chromium and opera browsers that will be discussed in the next section.', 'bow': [['contain', 'outlook', 'firefox', 'stealer', 'function', 'abil', 'steal', 'login', 'inform', 'googl', 'chrome', ',', 'chromium', ',', 'fork', 'chromium', 'opera', 'browser', 'discuss', 'next', 'section'], ['steal', 'login', 'inform']], 'compact_vector': [{'what': 'contains', 'where': 'outlook firefox stealer functionality ability google chrome , chromium , forks chromium opera browsers discussed next section', 'why': '', 'how': '', 'when': ''}, {'what': 'steal', 'where': 'login information', 'why': '', 'how': '', 'when': ''}]}, {'text': 'the chrome, chromium, chromium forks and opera credential stealing functionality opens the [database path]\\login data sqlite3 database, reads the url, username, and password fields, and calls cryptunprotectdata to decrypt user passwords.', 'bow': [['steal', 'credenti'], ['open', '[', 'databas', 'path'], ['read', 'url', ',', 'usernam', ',', 'password', 'field'], ['decrypt', 'user', 'password']], 'compact_vector': [{'what': 'stealing', 'where': 'credential', 'why': '', 'how': '', 'when': ''}, {'what': 'opens', 'where': '[ database path', 'why': '', 'how': '', 'when': ''}, {'what': 'reads', 'where': 'url , username , password fields', 'why': '', 'how': '', 'when': ''}, {'what': 'decrypt', 'where': 'user passwords', 'why': '', 'how': '', 'when': ''}]}, {'text': 'the following paths are checked for this database.', 'bow': [['follow', 'path'], ['check', 'follow', 'path']], 'compact_vector': [{'what': 'checked', 'where': 'following paths', 'why': '', 'how': '', 'when': ''}]}, {'text': 'although opera is not a fork of chromium, the newest version has credentials with the same implementation under the path.', 'bow': [], 'compact_vector': []}, {'text': '\\opera software\\opera stable\\login data', 'bow': [], 'compact_vector': []}, {'text': 'in addition to the javascript bot functionality, the stolen data is dumped to %appdata%\\%username%.ini and sets the file creation time to be that of ntdll.dll.', 'bow': [['stolen', 'data'], ['dump', 'stolen', 'data']], 'compact_vector': [{'what': 'dumped', 'where': 'stolen data', 'why': '', 'how': '', 'when': ''}]}, {'text': 'this data is read and encrypted using the simpleencrypt function, which as their name implies, is a simple substitution cipher.', 'bow': [['read', 'data'], ['encrypt', 'data'], ['use', 'simpleencrypt', 'function', ',', 'name', 'impli', ',', 'simpl', 'substitut', 'cipher']], 'compact_vector': [{'what': 'encrypted', 'where': 'data', 'why': '', 'how': 'using simpleencrypt function , name implies , simple substitution cipher', 'when': ''}, {'what': 'using', 'where': 'simpleencrypt function , name implies , simple substitution cipher', 'why': '', 'how': '', 'when': ''}]}, {'text': 'this is then posted to a hardcoded command and control addresses, including the google apps script hosting service (also notice the alfin variable declaration which is the alphabet used for the substitution cipher).', 'bow': [], 'compact_vector': []}, {'text': 'this is again using the comment block evasion technique.', 'bow': [['use', 'comment', 'block', 'evas', 'techniqu']], 'compact_vector': [{'what': 'using', 'where': 'comment block evasion technique', 'why': '', 'how': '', 'when': 'again'}]}]

isSymantecReport = True

prev_verb = ''
prev_subject = ''
prev_object = ''
prev_sentence = ''

if __name__=='__main__':

    pass
